<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Camera Connect â€” Confirmed Share (Firebase)</title>
  <style>
    :root{--primary:#1e88e5;--muted:#666}
    body{font-family:Arial,Helvetica,sans-serif;margin:18px;background:#f4f7fb;color:#222}
    .wrap{max-width:920px;margin:0 auto}
    h1{text-align:center;color:var(--primary)}
    .card{background:#fff;border-radius:10px;padding:12px;margin:14px 0;border:1px solid #e6eef9}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    label{display:inline-flex;align-items:center;gap:8px}
    button{background:var(--primary);color:#fff;border:none;padding:10px 14px;border-radius:8px;cursor:pointer}
    button.secondary{background:#37474f}
    input[type=text]{padding:8px;border-radius:6px;border:1px solid #cfd8dc}
    video{width:100%;max-width:720px;background:#000;border-radius:8px;display:block;margin:10px 0}
    .code{font-family:monospace;background:#eef5ff;padding:8px;border-radius:6px;display:inline-block}
    .small{font-size:13px;color:#555}
    .hidden{display:none}
    #status{font-size:14px;color:#2e7d32;margin-top:8px}
    /* modal */
    .modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,0.45);display:flex;align-items:center;justify-content:center;z-index:9999}
    .modal{background:#fff;padding:18px;border-radius:12px;max-width:420px;width:92%;box-shadow:0 8px 30px rgba(0,0,0,0.25)}
    .modal h3{margin:0 0 8px}
    .modal p{color:var(--muted);margin:8px 0 14px}
    .modal .actions{display:flex;gap:8px;justify-content:flex-end}
    .btn-accept{background:#2e7d32}
    .btn-reject{background:#c62828}
    .center{text-align:center}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Camera Connect â€” Confirmed Share</h1>

    <div class="card">
      <div class="row">
        <button id="modeSend">ðŸ“¤ Send (Share)</button>
        <button id="modeRecv">ðŸ“¥ Receive (View)</button>
        <div style="margin-left:auto" class="small">Uses Firestore for signaling</div>
      </div>
    </div>

    <!-- Sender -->
    <div id="senderCard" class="card hidden">
      <h3>Sender â€” Share your camera</h3>
      <div class="row">
        <label><input type="checkbox" id="shareVideo" checked> Camera</label>
        <label><input type="checkbox" id="shareAudio" checked> Mic</label>
        <button id="startShare">Start Share</button>
        <button id="stopShare" class="secondary hidden">Stop</button>
      </div>

      <div style="margin-top:12px">
        <div class="small">Session code â€” give to viewer:</div>
        <div id="sessionCode" class="code" style="margin-top:8px">â€”</div>
      </div>

      <div style="margin-top:12px">
        <div class="small">Local preview:</div>
        <video id="localVideo" autoplay playsinline muted></video>
      </div>

      <div id="senderStatus" class="small" style="margin-top:8px;color:#2e7d32"></div>
    </div>

    <!-- Receiver -->
    <div id="recvCard" class="card hidden">
      <h3>Receiver â€” Connect to a sender</h3>
      <div class="row">
        <input id="codeInput" placeholder="Enter session code (e.g. AB12CD)" type="text" />
        <button id="btnJoin">Connect</button>
        <button id="btnLeave" class="secondary hidden">Disconnect</button>
      </div>

      <div style="margin-top:12px">
        <div class="small">Remote stream:</div>
        <video id="remoteVideo" autoplay playsinline></video>
      </div>

      <div id="recvStatus" class="small" style="margin-top:8px;color:#2e7d32"></div>
    </div>

    <div class="card small">
      <strong>Notes:</strong>
      <ul>
        <li>Host over HTTPS (GitHub Pages) or run `http://localhost` with a local server.</li>
        <li>For better connectivity across NATs, add a TURN server to the configuration.</li>
      </ul>
    </div>
  </div>

  <!-- Confirmation Modal (custom) -->
  <div id="confirmModal" class="modal-backdrop hidden" aria-hidden="true">
    <div class="modal">
      <h3>Connection request</h3>
      <p><strong>A viewer is trying to connect.</strong><br/>Do you want to allow them to view your camera?</p>
      <div class="actions">
        <button id="rejectBtn" class="btn-reject">Reject</button>
        <button id="allowBtn" class="btn-accept">Allow</button>
      </div>
    </div>
  </div>

  <!-- Firebase SDKs (compat) -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>

  <script>
  // ----- YOUR FIREBASE CONFIG -----
  const firebaseConfig = {
    apiKey: "AIzaSyA6C0obBf1DhLGqeslZervMQhYTAnhJNz0",
    authDomain: "camera-a8909.firebaseapp.com",
    projectId: "camera-a8909",
    storageBucket: "camera-a8909.firebasestorage.app",
    messagingSenderId: "684343813628",
    appId: "1:684343813628:web:218292a6173fbe9c1dfe79",
    measurementId: "G-LDDDKW79JY"
  };
  // --------------------------------

  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();

  // UI refs
  const modeSend = document.getElementById('modeSend');
  const modeRecv = document.getElementById('modeRecv');

  const senderCard = document.getElementById('senderCard');
  const recvCard = document.getElementById('recvCard');

  const shareVideoChk = document.getElementById('shareVideo');
  const shareAudioChk = document.getElementById('shareAudio');
  const startShareBtn = document.getElementById('startShare');
  const stopShareBtn = document.getElementById('stopShare');
  const sessionCodeEl = document.getElementById('sessionCode');
  const localVideo = document.getElementById('localVideo');
  const senderStatus = document.getElementById('senderStatus');

  const codeInput = document.getElementById('codeInput');
  const btnJoin = document.getElementById('btnJoin');
  const btnLeave = document.getElementById('btnLeave');
  const remoteVideo = document.getElementById('remoteVideo');
  const recvStatus = document.getElementById('recvStatus');

  const confirmModal = document.getElementById('confirmModal');
  const allowBtn = document.getElementById('allowBtn');
  const rejectBtn = document.getElementById('rejectBtn');

  // state
  let pc = null;
  let localStream = null;
  let sessionRef = null;
  let senderCandsUnsub = null;
  let receiverCandsUnsub = null;
  let sessionSnapshotUnsub = null;

  const ICE_CONFIG = {
    iceServers: [
      { urls: 'stun:stun.l.google.com:19302' }
      // Add TURN server here if available.
    ]
  };

  // helpers
  function makeCode(len=6){
    const chars = 'ABCDEFGHJKMNPQRSTUVWXYZ23456789';
    let s=''; for(let i=0;i<len;i++) s+=chars[Math.floor(Math.random()*chars.length)];
    return s;
  }

  function showModal(){ confirmModal.classList.remove('hidden'); confirmModal.setAttribute('aria-hidden','false'); }
  function hideModal(){ confirmModal.classList.add('hidden'); confirmModal.setAttribute('aria-hidden','true'); }

  // navigation
  modeSend.onclick = ()=>{ senderCard.classList.remove('hidden'); recvCard.classList.add('hidden'); }
  modeRecv.onclick = ()=>{ recvCard.classList.remove('hidden'); senderCard.classList.add('hidden'); }

  // ---------- SENDER FLOW ----------
  startShareBtn.onclick = async ()=>{
    startShareBtn.disabled = true;
    senderStatus.textContent = 'Starting... allow camera/mic when asked.';
    const useVideo = shareVideoChk.checked;
    const useAudio = shareAudioChk.checked;
    try {
      localStream = await navigator.mediaDevices.getUserMedia({video:useVideo, audio:useAudio});
      localVideo.srcObject = localStream;
    } catch(e){
      alert('Camera/Mic access failed: ' + e);
      startShareBtn.disabled = false;
      senderStatus.textContent = '';
      return;
    }

    pc = new RTCPeerConnection(ICE_CONFIG);
    localStream.getTracks().forEach(t=>pc.addTrack(t, localStream));

    // create new session doc
    const code = makeCode(6);
    sessionCodeEl.textContent = code;
    sessionRef = db.collection('sessions').doc(code);

    // subcollections
    const senderCandCol = sessionRef.collection('senderCandidates');
    const receiverCandCol = sessionRef.collection('receiverCandidates');

    // push local ICE to senderCandidates
    pc.onicecandidate = e=>{
      if(e.candidate){
        senderCandCol.add(e.candidate.toJSON()).catch(console.error);
      }
    };

    // remote tracks (sender normally doesn't show remote, but safe)
    pc.ontrack = e=>{
      console.log('Sender got remote track', e.streams);
    };

    // create offer and save
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    const offerData = { type: offer.type, sdp: offer.sdp, createdAt: firebase.firestore.FieldValue.serverTimestamp() };
    await sessionRef.set({ offer: offerData, status:'waiting' }, { merge: true });

    // listen for receiverCandidates and add to pc
    receiverCandsUnsub = receiverCandCol.onSnapshot(snapshot=>{
      snapshot.docChanges().forEach(change=>{
        if(change.type === 'added'){
          const cand = change.doc.data();
          pc.addIceCandidate(new RTCIceCandidate(cand)).catch(e=>console.warn('addIceCandidate failed', e));
        }
      });
    });

    // listen for session doc updates (incoming request / answer / status)
    sessionSnapshotUnsub = sessionRef.onSnapshot(async snap=>{
      const data = snap.data();
      if(!data) return;

      // If a receiver requested connection (receiver sets request: true)
      if(data.request === true && !data.requestHandled){
        // show confirmation modal to sender
        senderStatus.textContent = 'Connection request received â€” awaiting approval...';
        showModal();

        // Wait for user action via modal buttons (allow/reject)
        // When allowBtn clicked, we will set requestHandled=true and approved=true
        // When rejectBtn clicked, set requestHandled=true and rejected=true
      }

      // If receiver was approved and provided answer
      if(data.approved === true && data.answer && pc && !pc.currentRemoteDescription){
        try {
          const ans = data.answer;
          const answerDesc = new RTCSessionDescription({ type: ans.type, sdp: ans.sdp });
          await pc.setRemoteDescription(answerDesc);
          senderStatus.textContent = 'Viewer connected â€” streaming.';
        } catch(err){
          console.error('Error applying answer', err);
        }
      }

      // If rejected status
      if(data.rejected === true){
        senderStatus.textContent = 'Viewer request rejected.';
      }
    });

    // store for cleanup
    sessionRef._senderCandUnsub = senderCandsUnsub;
    sessionRef._receiverCandUnsub = receiverCandsUnsub;

    senderStatus.textContent = 'Session created. Share code: ' + code;
    stopShareBtn.classList.remove('hidden');
  };

  // modal button events (sender approves/rejects)
  allowBtn.onclick = async ()=>{
    hideModal();
    senderStatus.textContent = 'Approved viewer â€” waiting for connection...';
    try {
      await sessionRef.update({ approved: true, requestHandled: true, status:'approved' });
    } catch(e){ console.warn(e); }
  };

  rejectBtn.onclick = async ()=>{
    hideModal();
    senderStatus.textContent = 'Rejected viewer request.';
    try {
      await sessionRef.update({ rejected: true, requestHandled: true, status:'rejected' });
    } catch(e){ console.warn(e); }
  };

  stopShareBtn.onclick = async ()=>{
    await cleanup(true);
  };

  // ---------- RECEIVER FLOW ----------
  btnJoin.onclick = async ()=>{
    const code = (codeInput.value||'').trim().toUpperCase();
    if(!code) return alert('Enter session code');

    recvStatus.textContent = 'Contacting sender...';
    btnJoin.disabled = true;

    try {
      sessionRef = db.collection('sessions').doc(code);
      const snap = await sessionRef.get();
      if(!snap.exists){
        alert('Session not found');
        recvStatus.textContent = '';
        btnJoin.disabled = false;
        sessionRef = null;
        return;
      }
      const data = snap.data();
      if(!data.offer){
        alert('Sender has not created an offer yet.');
        recvStatus.textContent = '';
        btnJoin.disabled = false;
        sessionRef = null;
        return;
      }

      // create RTCPeerConnection and wait for approval before making answer
      pc = new RTCPeerConnection(ICE_CONFIG);
      pc.ontrack = e=>{
        remoteVideo.srcObject = e.streams[0];
        recvStatus.textContent = 'Streaming.';
      };

      const receiverCandCol = sessionRef.collection('receiverCandidates');
      const senderCandCol = sessionRef.collection('senderCandidates');

      // send local ICE to receiverCandidates
      pc.onicecandidate = e=>{
        if(e.candidate){
          receiverCandCol.add(e.candidate.toJSON()).catch(console.error);
        }
      };

      // listen for senderCandidates and add to pc
      senderCandsUnsub = senderCandCol.onSnapshot(snapshot=>{
        snapshot.docChanges().forEach(async change=>{
          if(change.type === 'added'){
            const cand = change.doc.data();
            try {
              await pc.addIceCandidate(new RTCIceCandidate(cand));
            } catch(e){
              console.warn('addIceCandidate error', e);
            }
          }
        });
      });

      // set remote description with offer
      const offer = data.offer;
      await pc.setRemoteDescription(new RTCSessionDescription({ type: offer.type, sdp: offer.sdp }));

      // Instead of immediately creating answer, write a "request" flag so sender can confirm
      await sessionRef.update({ request: true, requestTime: firebase.firestore.FieldValue.serverTimestamp() });

      // listen for approval/rejection
      const unsub = sessionRef.onSnapshot(async snap2=>{
        const d = snap2.data();
        if(!d) return;

        if(d.rejected === true){
          recvStatus.textContent = 'Sender rejected your request.';
          alert('Sender rejected the connection.');
          cleanup(false);
        }

        if(d.approved === true && d.answer){
          // sender approved and perhaps answer exists (sender will wait for answer creation)
          // But we (receiver) still need to create an answer and set it in the doc.
          try {
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            // save answer to doc (merge:true)
            const ansData = { type: answer.type, sdp: answer.sdp, answeredAt: firebase.firestore.FieldValue.serverTimestamp() };
            await sessionRef.set({ answer: ansData, status:'answered' }, { merge: true });
            recvStatus.textContent = 'Answer sent. Waiting for media...';
            btnLeave.classList.remove('hidden');
            // stop listening for approval changes after answer set
            unsub();
          } catch(err){
            console.error('Error creating/saving answer', err);
            recvStatus.textContent = 'Error creating answer: ' + err;
            btnJoin.disabled = false;
          }
        }
      });

      // Also subscribe to sender doc changes: if sender deletes or rejects we handle above.

    } catch(err){
      console.error(err);
      alert('Error joining: ' + err);
      recvStatus.textContent = '';
      btnJoin.disabled = false;
      sessionRef = null;
    }
  };

  btnLeave.onclick = async ()=>{
    await cleanup(false);
  };

  // cleanup function
  async function cleanup(removeDoc=false){
    try {
      if(senderCandsUnsub){ senderCandsUnsub(); senderCandsUnsub = null; }
      if(receiverCandsUnsub){ receiverCandsUnsub(); receiverCandsUnsub = null; }
      if(sessionSnapshotUnsub){ sessionSnapshotUnsub(); sessionSnapshotUnsub = null; }
      if(sessionRef && sessionRef._localUnsub){ sessionRef._localUnsub(); delete sessionRef._localUnsub; }
    } catch(e){ console.warn(e); }

    if(pc){
      try { pc.getSenders().forEach(s=>s.track && s.track.stop()); } catch(e){}
      try { pc.close(); } catch(e){}
      pc = null;
    }
    if(localStream){
      try { localStream.getTracks().forEach(t=>t.stop()); } catch(e){}
      localStream = null;
      localVideo.srcObject = null;
    }
    if(remoteVideo) remoteVideo.srcObject = null;

    // delete session doc (if sender asked to remove)
    if(sessionRef && removeDoc){
      try {
        await sessionRef.delete();
      } catch(e){ console.warn('delete doc failed', e); }
    }

    // UI reset
    startShareBtn.disabled = false;
    stopShareBtn.classList.add('hidden');
    btnJoin.disabled = false;
    btnLeave.classList.add('hidden');
    sessionCodeEl.textContent = 'â€”';
    senderStatus.textContent = '';
    recvStatus.textContent = '';
    sessionRef = null;
    hideModal();
  }

  // page unload cleanup
  window.addEventListener('beforeunload', async ()=>{ await cleanup(false); });

  </script>
</body>
</html>
